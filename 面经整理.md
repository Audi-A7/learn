# 面经整理

标签（空格分隔）： 整理

---

题目连接列表
======

 1. https://www.jianshu.com/p/5ad977cd3113
 2. https://www.jianshu.com/p/05d44e107470

针对[链接2][1]的笔记（字节跳动）
--------

 **1. 虚拟内存是什么干什么用的？**
 
https://blog.csdn.net/qq_30137611/article/details/66478426

虚拟内存的引入主要还是为了应对物理内存有限的情形,操作系统引入了虚拟内存,且加入了逻辑地址 物理地址的概念,CPU在请求资源数据的时候,一般都是先将虚拟地址给MMU(内存管理单元),MMU请求页表(页表中的数据,有可能在内存,也有可能在磁盘),获得虚拟地址对应的物理地址,如果物理地址对应的数据在磁盘,会首先将数据缓冲到内存,如果本身就在内存,那么直接返回物理地址对应位置的数据给CPU.

总结来说就是如下几步:

 - 第一步：处理器生成一个虚拟地址（VA），并把它传送给MMU
 - 第二步：MMU生成页表条目的地址（PTEA），请求内存中的页表，让它给自己返回一个页表条目（PTE）
 - 第三步：MMU构造物理地址（PA），然后把这这个物理地址传给内存（这时候是真实的物理地址），请求物理内存中的数据
 - 第四步：内存返回所请求的数据给处理器

下面是博客里的一张示意图:

![此处输入图片的描述][2]

 **1. HTTP协议包括哪几种请求?如何保证幂等性?**

https://www.cnblogs.com/ranyonsue/p/5984001.html

注意http协议是无状态的,即如果后续请求需要前面请求的信息,那么它必须进行重传.

http请求可以细分为8种,分别如下:

 - GET     请求指定的页面信息，并返回实体主体。
 - HEAD     类似于get请求，只不过返回的响应中没有具体的内容，用于获取报头
 - POST    向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的建立和/或已有资源的修改。
 - PUT     从客户端向服务器传送的数据取代指定的文档的内容。
 - DELETE      请求服务器删除指定的页面。
 - CONNECT     HTTP/1.1协议中预留给能够将连接改为管道方式的代理服器。
 - OPTIONS     允许客户端查看服务器的性能。
 - TRACE     回显服务器收到的请求，主要用于测试或诊断。

其中,HTTP1.0定义了三种请求方法： GET, POST 和 HEAD方法。
HTTP1.1新增了五种请求方法：OPTIONS, PUT, DELETE, TRACE 和 CONNECT 方法。

HTTP之请求消息Request

客户端发送一个HTTP请求到服务器的请求消息包括以下格式：**请求行（request line）、请求头部（header）、空行和请求数据**四个部分组成。如下图所示:
![此处输入图片的描述][3]

 - Get请求例子，使用Charles抓取的request：

```http
GET /562f25980001b1b106000338.jpg HTTP/1.1
Host    img.mukewang.com
User-Agent    Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/51.0.2704.106 Safari/537.36
Accept    image/webp,image/*,*/*;q=0.8
Referer    http://www.imooc.com/
Accept-Encoding    gzip, deflate, sdch
Accept-Language    zh-CN,zh;q=0.8

```
注意:请求头部后面的空行是必须的,即使第四部分的请求数据为空，也必须有空行(这个例子的请求数据为空).

 - POST请求例子，使用Charles抓取的request：
```http
POST / HTTP1.1
Host:www.wrox.com
User-Agent:Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; .NET CLR 2.0.50727; .NET CLR 3.0.04506.648; .NET CLR 3.5.21022)
Content-Type:application/x-www-form-urlencoded
Content-Length:40
Connection: Keep-Alive

name=Professional%20Ajax&publisher=Wiley
```


HTTP之响应消息Response

HTTP响应也由四个部分组成，分别是：状态行、消息报头、空行(必须要有)和响应正文。如下图所示:
![此处输入图片的描述][4]

下面是一个具体的例子:
```http
HTTP/1.1 200 OK
Date: Fri, 22 May 2009 06:07:21 GMT
Content-Type: text/html; charset=UTF-8

<html>
      <head></head>
      <body>
            <!--body goes here-->
      </body>
</html>
```

**http协议如何保证幂等性?**

https://blog.csdn.net/Patrick_1993/article/details/82633726

幂等性指的是一次请求和多次请求某一资源具有同样的副作用。比如，你采用 GET 请求银行账户的余额，虽然结果不一定相同，可是并无副作用，因此是幂等的。而如果采用 POST请求提交扣款，多次提交产生不同的副作用，因此不满足幂等性。

 - GET 请求用于获取资源，无副作用，所以是幂等的。
 - DELETE 请求用于删除资源，有副作用，但是，DELETE 同一资源，无论调用一次还是调用多次，其副作用是相同的，因此也满足幂等性。
 - PUT 方法用于创建或更新操作，有副作用，与 DELETE 相同，对同一资源无论调用一次还是多次，其副作用是相同的，因此也满足幂等性。
 - POST 方法与 PUT 方法的区别主要在于幂等性，**POST 不具备幂等性**，因为 POST 请求每次都会创建一个文件，而 PUT方法会在服务器验证是否有 ENTITY，若有则更新该 ENTITY而不是重新创建。

kkkk

 **1. 输入一个网址到浏览器渲染出页面的过程中有哪些报文，分别涉及哪些协议，协议的主要内容是啥，分别用来做什么的?**

https://blog.csdn.net/u014590757/article/details/80035410

 - 浏览器获取输入的域名www.baidu.com
 - 浏览器向DNS请求解析www.baidu.com的IP地址
 - 域名系统DNS解析出百度服务器的IP地址
 - 浏览器发出HTTP请求，请求百度首页
 - 浏览器与该服务器建立TCP连接(默认端口号80)
 - 服务器通过HTTP响应把首页文件发送给浏览器
 - TCP连接释放
 - 浏览器将首页文件进行解析，并将Web页显示给用户。

涉及到的相关协议:

(1) 应用层：HTTP(WWW访问协议)，DNS(域名解析服务) 
DNS解析域名为目的IP，通过IP找到服务器路径，客户端向服务器发起HTTP会话，然后通过运输层TCP协议封装数据包，在TCP协议基础上进行传输

(2) 传输层：TCP(为HTTP提供可靠的数据传输)，UDP(DNS使用UDP传输) 
HTTP会话会被分成报文段，添加源、目的端口；TCP协议进行主要工作

(3)网络层：IP(IP数据数据包传输和路由选择)，ICMP(提供网络传输过程中的差错检测)，ARP(将本机的默认网关IP地址映射成物理MAC地址) 为数据包选择路由，ARP协议将IP地址转成MAC地址。

数据流向:HTTP数据包(应用层)->TCP报文段(传输层)->IP数据包(网络层)->数据帧(数据链路层)

 **1. 如果让你设计一个下载器中的断点续传功能，你打算怎么设计，会有哪些问题?**
 
 https://www.jianshu.com/p/75271ec07c75
 
 https://blog.csdn.net/zgaoq/article/details/72778922
 
 

 **1. 概率问题**

 有一个袋子里面装了黑白两种颜色的球若干个，现在每次从袋子里面摸两个球，如果摸到的是相同颜色的球那么将两个球丢弃并且重新放一个黑球进去，如果摸到的是不同颜色的球则将黑球白球放回，问最后袋子里面存在哪些情况并且详细说明过程，推导方法。
 
 

 - N黑(N为奇偶数都行)->1黑

 

 - N白(N为奇数)->1白1黑

 

 - N白(N为偶数)->1黑

 

 - M黑N白(M为奇偶数无所谓,N为奇)->1白1黑

 

 - M黑N白(M为奇偶数无所谓,N为偶)->1黑

 
 综上:最后只会1黑or1白1黑
 

如果将问题修改成摸到相同颜色的球直接丢弃不放回的话，这个时候整个过程会有哪些变化。

纯色球的时候,黑白都一样,以白球为例:

N白(N为奇数)->1白

N白(N为偶数)->0个球

M黑N白->1黑  or 1白 or  1黑1白  or 0个球

 **1. 有一台服务器，含有若干的CPU和内存资源，现在有一系列规格不等的虚拟机，设计算法最大化的利用服务器的资源并分析求解的复杂度?**
 
 这题的解题思路应该是使用贪心算法,后面再解决.
 

 **1. 手撕代码，给一个数组，将数组看做二叉树，输出二叉树的右半边部分，每一层要求逆序输出.**
 
 数组应该是按照层次遍历的方式输入的.其实,题目的意思,已知树的层次遍历,要输出树的右子树.
 
 

 **1. 什么是堆?最大堆最小堆?堆排序?**
 
 https://www.cnblogs.com/bakari/p/5490858.html
 
 这里所说的堆不是内存中的堆,而是一种数据结构,堆通常可以被看做是树结构，满足两个性质：**1）**堆中任意节点的值总是不大于（不小于）其子节点的值；**2）**堆是一棵完全树。
 
 **最大堆:**根节点的值不小于左右节点的值
 
 **最小堆:**根节点的值不大于左右节点的值
 
 http://www.cnblogs.com/dolphin0520/archive/2011/10/06/2199741.html
 
 堆排序的基本思想:首先构建最大(小)堆,然后将堆顶元素R1和Rn交换,调整树结构使其再次满足堆性质,然后重复上面的过程,知道交换了N-1次,就完成了堆排序.
 
 

 **1. TCP与UDP的区别**


 - TCP是有连接的,UDP是无无连接的；
 - 对系统资源的要求（TCP较多，UDP少）
 - TCP是**流**模式，UDP是**数据报**模式，原因可以参见https://www.cnblogs.com/jason2013/articles/4346639.html，总结来说就是：TCP由于可以保证顺序，且是一对一的通信，因此一次send多少或者一次receive多少，总是可以恢复出正确的信息。但是UDP不行，它不能保证顺序，且存在多个send一个receive的情况，假如来自两个send的报文信息合并了，那么将不能恢复出正确的原始信息来。
 - TCP保证数据正确性，UDP可能丢包，TCP保证数据顺序，UDP不保证
 - http协议（应用层）使用的就是TCP（传输层），常见的使用TCP还有FTP、SMTP、Telnet、QQ文件传输等。
 - DNS服务（原因层）使用的是UDP(传输层)，常见的使用UDP的还有语音电话、视频电话等。


----------

 **1. CAS用途及原理？**

https://www.cnblogs.com/longshiyVip/p/5211478.html

CAS，Compare And Swap，它含有三个操作数，内存数据v，旧的预期数据A，要修改的数据B，每次进行数据更新时，当且仅当预期值A和内存中的数据V相同时，才将内存中的数据修改为B，否则什么也不做。

使用这种机制编写的算法也叫非阻塞算法。

基本上JDK中atomic包下的很多类都是使用了这个原理，我们简单看一下AtomicInteger的部分源码：
```java
/**
     * Atomically updates the current value with the results of
     * applying the given function, returning the previous value. The
     * function should be side-effect-free, since it may be re-applied
     * when attempted updates fail due to contention among threads.
     *
     * @param updateFunction a side-effect-free function
     * @return the previous value
     * @since 1.8
     */
    public final int getAndUpdate(IntUnaryOperator updateFunction) {
        int prev, next;
        do {
            prev = get();
            next = updateFunction.applyAsInt(prev);
        } while (!compareAndSet(prev, next));
        return prev;
    }
    
    
    /**
     * Atomically sets the value to the given updated value
     * if the current value {@code ==} the expected value.
     *
     * @param expect the expected value
     * @param update the new value
     * @return {@code true} if successful. False return indicates that
     * the actual value was not equal to the expected value.
     */
    public final boolean compareAndSet(int expect, int update) {
        return unsafe.compareAndSwapInt(this, valueOffset, expect, update);
    }
```
上面的Unsafe为JNI的代码，锁分两种，一个叫悲观锁，一种称之为乐观锁。Synchronized就是悲观锁的一种，也称之为独占锁，加了synchronized关键字的代码基本上就只能以单线程的形式去执行了，它会导致其他需要该资源的线程挂起，直到前面的线程执行完毕释放所资源。而另外一种乐观锁是一种更高效的机制，它的原理就是每次不加锁去执行某项操作，如果发生冲突则失败并重试，直到成功为止，其实本质上不算锁，所以很多地方也称之为自旋（比如上面代码中的while循环）。

 **1. atomic包下有哪些实现类？原理是什么？**
 
 atomic包下的类，我们可以看一下下面的截图：
 
 ![此处输入图片的描述][5]

 atomic包中的操作原理大都基于CAS，具体的可以参考上面的笔记。
 
 

 **1. 0-1背包问题**
 
 https://www.cnblogs.com/xym4869/p/8513801.html
 
 参考上面的链接，重点是链接中的几张图，我贴在下面了：
 
 ![此处输入图片的描述][6]
 ![此处输入图片的描述][7]
 ![此处输入图片的描述][8]
 
 上面解释了递推公式的过程，以及原理。尤其注意图中的，当可以把第i个物品放入口袋的时候，那么也就是需要将之前的物品（不一定是之前的i-1个，因为还可能之前的某几个物品需要拿出来）放入容量为j-w(i)的背包中。
 
 此外，还需要注意的一点是：当背包装的物品的价值达到最大时，哪些物品被装入了，这个在上面的图中也有推倒。
 
 0-1背包问题的示例代码：
 
 ```java
 public int knapsack(int W, int N, int[] weights, int[] values) {
    int[][] dp = new int[N + 1][W + 1];
    for (int i = 1; i <= N; i++) {
        int w = weights[i - 1], v = values[i - 1];
        for (int j = 1; j <= W; j++) {
            if (j >= w) {
                dp[i][j] = Math.max(dp[i - 1][j], dp[i - 1][j - w] + v);
            } else {
                dp[i][j] = dp[i - 1][j];
            }
        }
    }
    return dp[N][W];
}
 ```
 
 

 **1. 最长公共子串**
 
 https://leetcode.com/problems/maximum-length-of-repeated-subarray/
 
 注意它的状态转移公式，且区别于最长公共子序列。
 
 

**1. redis的数据结构**

http://www.cnblogs.com/wxd0108/p/5729739.html

http://www.redis.net.cn/order/3593.html
 
 | 结构类型        | 可存储数据格式   |  数量  |相关指令|
| --------   | :-----:  | :----:  | :---- |
| String字符串     | 字符串，整数或者浮点数 |   对整个字符串或者字符串中的一部分执行操作，对整个整数或者浮点执行自增(increment)或者自减(decrement)操作     | 1、get、获取存储在指定键中的值 2、set、设置存储在指定键中的值 3、del、删除存储在指定键中的值（这个命令可以用于所有的类型）|
| List列表        |   一个链表，链表上的每个节点都包含了一个字符串   |   从链表的两端推入或者弹出元素，根据偏移量对链表进行修剪(trim)，读取单个或者多个元素，根据值查找或者移除元素   |1、rpush、将给定值推入列表的右端   2、lrange、获取列表在指定范围上的所有值  3、lindex、获取列表在指定范围上的单个元素  4、lpop、从列表的左端弹出一个值，并返回被弹出的值|
| Set集合        |    包含字符串的无序收集器（不可重复）   |  添加，获取，移除单个元素，检查一个元素是否存在于集合中，计算交集，并集，差集，从集合里面随机获取元素  |1、sadd、将给定元素添加到集合  2、smembers、返回集合包含的所有元素  3、sismember、检查指定元素是否存在于集合中  4、srem、检查指定元素是否存在于集合中，那么移除这个元素|
| Hash散列        |   包含key-value键值对无序散列表     |  添加，获取，移除当键值对，获取所有键值对  |1、hset、在散列里面关联起指定的键值对 2、hget、获取指定散列键的值 3、hgetall、获取散列包含的所有键值对 4、hdel、如果给定键存在于散列里面，那么移除这个键|
| Zset有序集合       |   字符串成员(member)与浮点数分值(score)之间的有序映射(score可以重复，但是member不能重复)    |  元素的排列顺序由分值的大小决定。添加，获取，删除单个元素，根据分值范围(range)或者成员来获取元素  |1、zadd、将一个带有给定分值的成员添加到有序集合里面 2、zrange、根据元素在有序排列中所处的位置，从有序集合里面获取多个元素 3、zrangebyscore、获取有序集合在给定分值范围内的所有元素 4、zrem、如果指定成员存在于有序集合中，那么移除这个成员|

**注意**：zset不能member重复，但是可以分值重复。member重复添加的时候，之前的member节点会被删除，新的member节点会被插入。分值重复的时候，节点的先后顺序按照member的字典序进行排序。

 **1. redis的keys命令在生产环境可以使用吗？**
 
 http://www.cnblogs.com/joshua317/p/5533917.html
 
 **不可以**，绝对不可以。由于执行keys命令，redis会锁定，如果数据庞大的话可能需要几秒或更长，对于生产服务器上锁定几秒这绝对是灾难了
 
 redis官方文档对于keys命令的warning解释：
 
 Warning: consider KEYS as a command that should only be used in production environments with extreme care. It may ruin performance when it is executed against large databases. This command is intended for debugging and special operations, such as changing your keyspace layout. Don’t use KEYS in your regular application code. If you’re looking for a way to find keys in a subset of your keyspace, consider using SCAN or sets.
 
 
 如果有这种需求的话可以自己对键值做索引，比如把各种键值存到不同的set里面，分类建立索引，这样就可以很快的得到数据，但是这样也存在一个明显的缺点，就是浪费宝贵的空间，要知道这可是内存空间啊，所以还是要合理考虑，当然也可以想办法，比如对于有规律的键值，可以存储他们的始末值等等。
 
 从redis的官方文档上看，2.8版本之后SCAN命令已经可用，允许使用游标从keyspace中检索键。对比KEYS命令，虽然SCAN无法一次性返回所有匹配结果，但是却规避了阻塞系统这个高风险，从而也让一些操作可以放在主节点上执行。

需要注意的是，SCAN 命令是一个基于游标的迭代器。SCAN 命令每次被调用之后， 都会向用户返回一个新的游标，用户在下次迭代时需要使用这个新游标作为 SCAN 命令的游标参数， 以此来延续之前的迭代过程。同时，使用SCAN，用户还可以使用keyname模式和count选项对命令进行调整。SCAN相关命令还包括SSCAN 命令、HSCAN 命令和 ZSCAN 命令，分别用于集合、哈希键及有续集等。


 

 **1. redis的跳跃表是怎么实现的？有什么用？为什么使用跳表而不使用平衡树？**
 
 https://blog.csdn.net/lz710117239/article/details/78408919
 
 跳表主要用于有序集合zset中，若一个有序集合包含的元素数量比较多，或者有序集合中的成员是比较长的字符串时，Redis就会使用跳跃表来作为有序集合键的底层实现。
 
 redis跳表底层实现，本质来说就是一个改良过的双向链表，每次创建一个新跳跃表结点的时候，程序都根据幂次定律（power law，越大的数出现的概率越小）随机生成一个介于**1和32**之间的值作为level数组的大小，这个大小就是该结点包含的层数。
 以下是跳跃表节点的定义：
 ```c++
 typedef struct zskiplistNode {  
    robj *obj;  
    double score;  
    struct zskiplistNode *backward;  
    struct zskiplistLevel {  
        struct zskiplistNode *forward;  
        unsigned int span;  
    } level[];  
} zskiplistNode;  
 ```
 代码中的span的概念，就是为了表明当前节点与forward指向的后向节点的之间的层跨度。
 
 下面是跳跃表的示意图：
 
 ![此处输入图片的描述][9]
 
  跳跃表头结点（header指向的节点）排名为0，之后的节点排名以此类推。在上图跳跃表中查找计算分值为3.0、成员对象为o3的结点的排名。查找过程只遍历了头结点的L5层就找到了，并且头结点该层的跨度为3，因此得到该结点在跳跃表中的排名为3。
  
  **为什么使用跳表而不使用平衡树？**
  
  https://blog.csdn.net/u010412301/article/details/64923131
  

 - skiplist和各种平衡树（如AVL、红黑树等）的元素是有序排列的，而哈希表不是有序的。因此，在哈希表上只能做单个key的查找，不适宜做范围查找。所谓范围查找，指的是查找那些大小在指定的两个值之间的所有节点。
 - 在做范围查找的时候，平衡树比skiplist操作要复杂。在平衡树上，我们找到指定范围的小值之后，还需要以中序遍历的顺序继续寻找其它不超过大值的节点。如果不对平衡树进行一定的改造，这里的中序遍历并不容易实现。而在skiplist上进行范围查找就非常简单，只需要在找到小值之后，对第1层链表进行若干步的遍历就可以实现。
 - 平衡树的插入和删除操作可能引发子树的调整，逻辑复杂，而skiplist的插入和删除只需要修改相邻节点的指针，操作简单又快速。
 - 从内存占用上来说，skiplist比平衡树更灵活一些。一般来说，平衡树每个节点包含2个指针（分别指向左右子树），而skiplist每个节点包含的指针数目平均为1/(1-p)，具体取决于参数p的大小。如果像Redis里的实现一样，取p=1/4，那么平均每个节点包含1.33个指针，比平衡树更有优势。
 - 查找单个key，skiplist和平衡树的时间复杂度都为O(logn)，大体相当；而哈希表在保持较低的哈希值冲突概率的前提下，查找时间复杂度接近O(1)，性能更高一些。所以我们平常使用的各种Map或dictionary结构，大都是基于哈希表实现的。
 - 从算法实现难度上来比较，skiplist比平衡树要简单得多。

lll

 **1. http的三次握手过程？为什么不是两次或者四次？**
 
 https://www.cnblogs.com/qdhxhz/p/8470997.html
 
 https://www.zhihu.com/question/24853633
 
 https://blog.csdn.net/lengxiao1993/article/details/82771768
 
 首先简要介绍一下tcp的6种标志位：
 SYN(建立联机)  ACK(确认)   PSH(传送)   FIN(结束)   RST(重置)    URG(紧急)  Sequence number(顺序号码)     Acknowledge number(确认号码)
 
 下面先说一下为什么不是**2次**握手？
 
 其实主要的原因还是因为，TCP为了保证可靠连接，通信的双方需要维护一个seq，用来表示哪些数据是被对方接收到的。两次握手的话，最多只能保证客户端的seq被服务端确认了，但是服务端却不知道自己的seq有没有被客户端确认。
 
另外一个**不太准确**的解释：client发送了第一个连接的请求报文，但是由于网络不好，这个请求没有立即到达服务端，而是在某个网络节点中滞留了，直到某个时间才到达server，本来这已经是一个失效的报文，但是server端接收到这个请求报文后，还是会想client发出确认的报文，表示同意连接。假如不采用三次握手，那么只要server发出确认，新的建立就连接了，但其实这个请求是失效的请求，client是不会理睬server的确认信息，也不会向服务端发送确认的请求，但是server认为新的连接已经建立起来了，并一直等待client发来数据，这样，server的很多资源就没白白浪费掉了，采用三次握手就是为了防止这种情况的发生，server会因为收不到确认的报文，就知道client并没有建立连接。这就是三次握手的作用。
 
 ![此处输入图片的描述][10]
 
 三次握手的过程如上图所示，下面介绍一下四次挥手的过程。
 
 ![此处输入图片的描述][11]
 
 第一次握手：TCP发送一个FIN(结束)，用来关闭客户到服务端的连接。

第二次握手：服务端收到这个FIN，他发回一个ACK(确认)，确认收到序号为收到序号+1，和SYN一样，一个FIN将占用一个序号。

第三次握手：服务端发送一个FIN(结束)到客户端，服务端关闭客户端的连接。

第四次握手：客户端发送ACK(确认)报文确认，并将确认的序号+1，这样关闭完成。

**为什么是四次挥手？**

可能有人会有疑问，tcp我握手的时候为何ACK(确认)和SYN(建立连接)是一起发送。挥手的时候为什么是分开的时候发送呢.
    因为当Server端收到Client端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当Server端收到FIN报文时，很可能并不会立即关闭             SOCKET，所以只能先回复一个ACK报文，告诉Client端，"你发的FIN报文我收到了"。只有等到我Server端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四步握手。
    
    

 **1. session解决用户登录信息保存的例子**
 
 https://github.com/CyC2018/CS-Notes/blob/master/notes/HTTP.md
 
 
 除了可以将用户信息通过 Cookie 存储在用户浏览器中，也可以利用 **Session存储在服务器端**，存储在服务器端的信息更加安全。

Session 可以存储在服务器上的文件、数据库或者内存中。也可以将 Session 存储在 Redis这种内存型数据库中，效率会更高。
 
 使用 Session 维护用户登录状态的过程如下：

 - 用户进行登录时，用户提交包含用户名和密码的表单，放入 HTTP 请求报文中；
 - 服务器验证该用户名和密码，如果正确则把用户信息存储到 Redis 中，它在 Redis 中的 Key 称为 Session ID；
 - 服务器返回的响应报文的 Set-Cookie 首部字段包含了这个 Session ID，客户端收到响应报文之后将该 Cookie值存入浏览器中；
 - 客户端之后对同一个服务器进行请求时会包含该 Cookie 值，服务器收到之后提取出 Session ID，从 Redis
   中取出用户信息，继续之前的业务操作。

应该注意 Session ID 的安全性问题，不能让它被恶意攻击者轻易获取，那么就不能产生一个容易被猜到的 Session ID 值。此外，还需要经常重新生成 Session ID。在对安全性要求极高的场景下，例如转账等操作，除了使用 Session 管理用户状态之外，还需要对用户进行重新验证，比如重新输入密码，或者使用短信验证码等方式。

 **1. Cookie 与 Session 选择（区别）**
 

 - Cookie 只能存储 ASCII 码字符串，而 Session 则可以存取任何类型的数据，因此在考虑数据复杂性时首选 Session；
 - Cookie 存储在浏览器中，容易被恶意查看。如果非要将一些隐私数据存在 Cookie 中，可以将 Cookie
   值进行加密，然后在服务器进行解密；
 - 对于大型网站，如果用户所有的信息都存储在 Session 中，那么开销是非常大的，因此不建议将所有的用户信息都存储到 Session 中。

lll

 **1. HTTPs协议**
 
 https://github.com/CyC2018/CS-Notes/blob/master/notes/HTTP.md
 
 HTTP 有以下安全性问题：
 

 - 使用明文进行通信，内容可能会被窃听；
 - 不验证通信方的身份，通信方的身份有可能遭遇伪装；
 - 无法证明报文的完整性，报文有可能遭篡改。

HTTPs 并不是新协议，而是让 HTTP 先和 SSL（Secure Sockets Layer）通信，再由 SSL 和 TCP 通信，也就是说 HTTPs 使用了隧道进行通信。

通过使用 SSL，HTTPs 具有了加密（防窃听）、认证（防伪装）和完整性保护（防篡改）。

![此处输入图片的描述][12]

HTTPs采用了对称、非对称加密结合的方式来进行数据的交互。使用非对称加密技术加密对称加密的秘钥，然后使用对称加密的秘钥去加密传输的数据。

这样做的好处是，利用了对称加密的加解密过程快速的优点，提高https的效率。

记住非对称加密的时候，使用的是公钥加密，私钥解密。

同样的，非对称加密也可以用于签名，这时候就是私钥签名，公钥验签。

https的加解密过程如下图所示：

![此处输入图片的描述][13]




 
 
 
 

 
 

 
 
 

 

 
 
 

 
 
 
 
 

 
 

 
 


  [1]: https://www.jianshu.com/p/05d44e107470
  [2]: https://github.com/WQZ321123/learn/blob/master/image/interview/VM.png?raw=true
  [3]: https://github.com/WQZ321123/learn/blob/master/image/interview/Http%E8%AF%B7%E6%B1%82%E6%B6%88%E6%81%AF%E7%BB%93%E6%9E%84.png?raw=true
  [4]: https://github.com/WQZ321123/learn/blob/master/image/interview/http%E5%93%8D%E5%BA%94%E6%B6%88%E6%81%AF%E6%A0%BC%E5%BC%8F.jpg?raw=true
  [5]: https://github.com/WQZ321123/learn/blob/master/image/interview/atomic%E5%8C%85.png?raw=true
  [6]: https://github.com/WQZ321123/learn/blob/master/image/interview/0-1%EF%BC%880%EF%BC%89.jpg?raw=true
  [7]: https://github.com/WQZ321123/learn/blob/master/image/interview/0-1%EF%BC%881%EF%BC%89.jpg?raw=true
  [8]: https://github.com/WQZ321123/learn/blob/master/image/interview/0-1%EF%BC%882%EF%BC%89.jpg?raw=true
  [9]: https://github.com/WQZ321123/learn/blob/master/image/interview/%E8%B7%B3%E8%B7%83%E8%A1%A8.jpg?raw=true
  [10]: https://github.com/WQZ321123/learn/blob/master/image/interview/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.png?raw=true
  [11]: https://github.com/WQZ321123/learn/blob/master/image/interview/%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B.png?raw=true
  [12]: https://github.com/WQZ321123/learn/blob/master/image/interview/https.jpg?raw=true
  [13]: https://github.com/WQZ321123/learn/blob/master/image/interview/How-HTTPS-Works.png?raw=true