---
title: note 
tags: 需求,排期,技术框架,完成时间
grammar_cjkRuby: true
---

# 数据库的扩展性设计
一个高度扩展性的分布式数据库架构应具备如下特性：
1.轻量级服务器的进程不应占用过多的CPU时间，而应通过我们的多个处理器并行运行多个实例。
2.客户端应用可连接多台服务器并从中提取数据。
3.通过数据复制技术，客户端应用可以从主数据库或从数据库中检索数据。
参考链接http://blog.csdn.net/stevensxiao/article/details/51872795
数据库的**横向扩展**支持三种方法，即主从复制，集群和分片(sharding)。
![数据库横向扩展][1]

  
  
  


  下面分别介绍一下三种技术：
  

 - 主从复制
 主从复制(Master-slave replication)，最易配置，对应用改动最小，并可以减轻主库的负担。 
主数据库可以读写，从数据库只读。最常用的场景就是实现读写分离，或业务分离，即运行报表，备份，数据仓库等应用。
这种方法的问题是主与从之间数据非完全同步，可能会读到两个不同的版本。另一个问题是，如果只有主库接受读写，那么主库迟早会过载，因此不算是真正的scale out。
不过主从库数据的延迟，有的业务是可以接受的。另外，利用一些实时复制的工具如GoldenGate，从库也是可以写的，这时可以利用从库做其它的业务，从而达到横向扩展的目的。这也算是主从复制的一个新趋势。
 - 集群
 集群也称为shared everything或shared disk架构。最知名的就是Oracle RAC。1个数据库可以有多个实例，来访问共享存储上的数据库。 
每一个节点都可以读写，从应用角度来看，代码无需改变。负载均衡也是自动的。
集群存在的问题包括： 
 1、写数据时需要内存中数据的同步，数据加速带来竞争，影响扩展性 
 2、难以设置和管理 
 3、由于存储是共享的，读操作也不能无限扩展

集群适合于读密集的应用，如数据仓库和BI。
 - 分片（Sharding）
 分区(Partition)是库内的，分片(Sharding)是库外的，也叫分表分库, 是shared nothing的架构。 
Sharding即将一个大的库拆分成很多小库。如何拆和业务规则有关，可以按用户ID拆，按业务拆。如果需要Join，相关的表需要放到一个库里，避免数据库间的通讯。

Sharding也可以有两种方法，即垂直分区和水平分区。

垂直分区是按业务分，简称为分库，即不同的业务使用不同的库，互不相干。垂直分区到一定程度，也无法扩展，这时需要水平分区。

水平分区则是将一个大表拆分为小表，每个小表位于不同的库。每一个建立相同的schema。如根据主键的hash值来分区。
sharding的不足在于： 
* 加大了应用代码的复杂性，需要路由到正确的shard。 
* 后期增加shard需要修改应用逻辑，并需要迁移数据(有点类似于hashmap的扩容函数) 
* 查询和聚集(aggregation)不再简单，需要跨库联合操作 
* 主数据和参照数据需要复制到所有shard，以避免跨库操作。主数据和参照数据虽然偏静态，但一旦修改，可能会有数据一致性问题。 
* 跨库修改需要分布式交易处理，会限制可扩展性。因此应尽量避免。 
* 单个shard的失效可能会使整个系统不可用（其实也不一定）。因此通常需要为每个shard再配置HA方案，如主从复制。

尽管有以上不足，分片对于一些大型网站还是广泛使用，如Google, eBay, Facebook, Flickr。
```java
When the pain is great, any medicine that reduces it is good, regardless of the side effects. 
```
还有一些其它一些新的数据库架构可以实现横向扩展，如NoSQL对于OLTP的扩展，Hadoop对于OLAP的扩展。
# 给表增加一列
参考链接：http://blog.csdn.net/u011001084/article/details/54630736
在大数据量，高并发的情况下，哪些方案是可行的，哪些是不可行的？
首先说说**不可行**的。
1、这种传统的sql语句是不可行的
```sql
alter table add column
```
2、通过增加表的方式扩展，依靠外键join来进行查询。
在大数据高并发的情况下，join的性能较差，不可行。
3、通过增加表的方式，使用视图来对外连接。
在大数据高并发的情况下，互联网公司不怎么使用视图，不可行。
哪些方案是**可行**的？
1、提前预留一些reserved字段
这个可以的，但是也不怎么优雅，一方面可能预留的字段不够，另外一方面预留过少，达不到扩展的效果。
2、通过增加表的方式，但是数据的连接是在service层进行，不是直接进行数据库的join连接操作。
3、新表+触发器+迁移数据+rename方案
这种方案的基本原理是：
以user(uid,name,password)扩展到user(uid,name,password,**age**,**sex**)，注意新增的两列。

 - 首先创建一个扩充字段后的新表，user(uid,name,password,age,sex)
 - 在原表user(uid,name,password)上新建三个触发器，分别为insert、update、delete，新表同步进行insert、update、delete
 - 分批次将旧表的数据迁移到新表，直至数据完成迁移。
 - 删除触发器、删除旧表
 - 把新表rename成原来的旧表的名字
本方案的缺点：
由于需要建立触发器，如果旧表已经存在很多的触发器，那么这种方案就行不通了（互联网大数据高并发的在线业务，一般都禁止使用触发器）。
触发器的建立会影响表的性能，所以整个数据的迁移需要在流量低峰的情况下进行。
参考链接http://blog.csdn.net/huangzhichang13/article/details/53695385

4、版本号+通用列的方案
假设有user表，该表中只有uid和name上有查询需求，那么该表可以设计为：
user（uid，name，version，ext），其中version为版本号，起到对ext字段进行版本说明的作用。ext字段建议存为json格式的数据，一方面节省存储量，另外一方面也便于程序对这个字段进行解析以及数据的提取。
假设，最开始的时候，只有password和nick两个字段，，那么数据存储实例如下图所示：
![版本0][2]


此时，如果需要增加字段age、sex，那么首先需要更改版本号，然后对ext列的数据做如下变更：

![版本1][3]


改方案的优点：

 - 可以灵活扩展属性
 - 多个版本的数据可以同时存在

该方案的缺点：

 - ext字段的数据无法建立索引
 - 对于ext字段的插入涉及到字符串的拼接，不直观
 - ext中的key值存在数据冗余，因为每一行都需要存储这些key，所以key要进来简短一些

该方案的改进：

 - 对于ext字段无法建立索引的问题，可以使用Nosql如MongoDB来进行处理

5、通过列转行的方式进行扩展
以user表为例，初期只有三个属性，可以设计为user（uid，key，value），数据存储格式如下图所示：
![方案5][4]


此时，增加两个字段，age、sex，新的数据存储格式如下图所示：
![方案5列扩展][5]


  [1]: http://i.imgur.com/6wW1gTz.png
  [2]: http://img.blog.csdn.net/20161216170243291
  [3]: http://img.blog.csdn.net/20161216170423687
  [4]: http://img.blog.csdn.net/20161216170701840
  [5]: http://img.blog.csdn.net/20161216170828560
  
本方案的优点：

 - 可以随时动态扩展属性
 - 新旧两种数据可以同时存在
 - 迁移数据方便，写个小程序可以将新增的属性加上
 - 各个属性上都可以查询
 
本方案的缺点：
 - key值有大量的冗余，所以key要尽量简短一些
 - 数据表的行数会很多，原来的一行记录会被拆分成很多行，查询效率会收到一定影响。

  
  