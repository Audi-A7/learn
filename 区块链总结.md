# 区块链总结    

标签（空格分隔）： 区块链

---

要求
==

2.精通一门语言，JAVA，C++或者GO均可，具备良好学习能力，能在短期内熟练掌握新的语言。

3.对操作系统，编译原理，网络原理，加密算法等**底层**技术有相当的兴趣及研究。

4.熟悉区块链的**原理**，熟悉开源项目，HyperLedger fabric、Ethereum、bitcoin、Corda；对区块链有浓厚兴趣，有区块链研发经验者优先。

5.有开源软件开发经验者优先，有大型系统架构设计经验者优先。

6.有良好的沟通协调能力和应变能力。

1、熟练掌握以太坊/比特币/区块链的**原理、机制**；
2、理解主流**共识算法**，包括不限于PoW，PoS，DPoS，PBFT，Paxos，Raft等；
3、熟悉**智能合约**和Solidity编程优先；
4、熟悉各种数据结构和算法，对密码学，安全协议和**加密算法**有研究；
5、Hyperledge， 以太坊等公开区块链项目研究或参与者

区块链
===

简单来讲，区块链是一个分布式的记账本，核心在于去中心化以及可信任链。 区块链技术的典型应用场景就是支付和清算，可以解决不同主体之间的信任问题。 区块链采用密码学的方法来保证已有数据的不可篡改性，主要包括密码学哈希函数和非对称加密（即有公钥和私钥）。

参考链接：
https://blog.csdn.net/qq_35440678/article/details/79538992

1、共识机制、共识算法
2、区块链中的密码学技术
3、智能合约和solidity编程
4、超级账本Hyperledge
 

 1. 什么是共识机制?
-----------

区块链可以看作一本记录所有交易的分布式公开帐簿，区块链网络中的每个参与者都把它看作一本所有权的权威记录。每个链上的参与方权利都是均等的，大家都可以往区块链上写入数据。
由于各个节点权利均等，没有中心化权威认证。如何保证某个节点写入区块链的数据是正确的，或者是被其他节点所认可的？
为了解决这个问题，于是就出现了共识机制。
 

 2. 主流的共识算法有哪些？
--------------
PoW、PoS、DPoS、raft、PBFT、smart-BFT

 - PoW
Proof of Work，工作量证明，该共识算法的共识结果在后续是可以推翻的，但是推翻的概率随着时间的推移会越来越小。比特币采用的就是这种共识算法。
block的版本 version
上一个block的hash值: prev_hash
需要写入的交易记录的hash树的值: merkle_root
更新时间: ntime
当前难度: nbits
挖矿的过程就是找到x使得以下等式成立：
```java
SHA256(SHA256(version + prev_hash + merkle_root + ntime + nbits + x )) < TARGET
```

 - PoS
Proof of Stake，权益证明，类似现实生活中的股东机制，拥有股份越多的人越容易获取记账权。
典型的过程是通过保证金（代币、资产、名声等具备价值属性的物品即可）来对赌一个合法的块成为新的区块，收益为抵押资本的利息和交易服务费。提供证明的保证金（例如通过转账货币记录）越多，则获得记账权的概率就越大。合法记账者可以获得收益。
PoS 是试图解决在 PoW 中大量资源被浪费的缺点。恶意参与者将存在保证金被罚没的风险，即损失经济利益。
一般的，对于 PoS 来说，需要掌握超过全网**1/3**的资源，才有可能左右最终的结果。这个也很容易理解，三个人投票，前两人分别支持一方，这时候，第三方的投票将决定最终结果。

 - DPoS
PoS 的改进算法，DPOS与POS原理相似。与POS的主要区别在于节点选举若干代理，由代理人验证和记账。
PoW机制和PoS机制虽然都能有效地解决记账行为的一致性共识问题，但是现有的比特币PoW机制纯粹依赖算力，导致专业从事挖矿的矿工群体似乎已和比特币社区完全分隔，某些矿池的巨大算力俨然成为另一个中心，这与比特币的去中心化思想相冲突。PoS机制虽然考虑到了PoW的不足，但依据权益结余来选择，会导致首富账户的权力更大，有可能支配记账权。
股份授权证明机制( Delegated Proof of Stake，DPoS)的出现正是基于解决PoW机制和PoS机制的这类不足。
DPOS机制是让每一个持有代币的人对整个系统资源当代表的人进行投票，而获得最多票数的101个代表进行交易打包计算。这个可以理解为101个矿池，而这101个矿池彼此的权利是完全相等的。那些握着代币选票的人可以随时通过投票更换这些代表（矿池），只要他们提供的算力不稳定，计算机宕机、或者试图利用手中的权力作恶，他们将会立刻被愤怒的选民门踢出整个系统，而后备代表可以随时顶上去。

 - raft
http://www.jdon.com/artichect/raft.html

raft强调节点可以宕机，但是不能作恶。也就是可以不反馈结果，但是不能故意返回错误的结果。
raft协议只要超过1/2支持就可以。

 

3. 目前主流区块链分别用的是什么共识算法？
----------------------

PoW共识算法代表：比特币&莱特币&以太坊
PoS机制代表：Peercoin & Nxt
DPoS共识算法代表：Bitshare & EOS


比特币
===

白皮书摘要
-----
现有的p2p网络，发送一笔交易，可以通过数字签名等方式，可以保证交易的有效性。但是对于双花的情景，仅仅通过数字签名是不能得到保证的。所以这个时候，比特币就提出了使用PoW方式共识来提供保证。
对于传统金融交易体系，我们一般需要一个共同信任的第三方来进行公正，保证交易的双方都是合法的。第三方的公信力，取决于第三方的维护成本，如果成本很低，那么其实第三方公信力相应的也就很低。
比特币交易的时候，假设A给B 1个BTC，那么按照白皮书描述的，过程如下：A使用自己的私钥对如下信息进行签名，hash（上一个交易+B的公钥），接收者可以对签名进行验证，从而确认交易的有效性。

源代码阅读笔记(版本git checkout 4405b78d6059e536c36974088a8ed4d9f0f29898)
-------
一个BA（BITCOIN APPLICATION）的四个主要任务：

 1. 组装交易
 2. 与其他BA节点进行交互
 3. 挖矿运算区块
 4. 保存区块
 
比特币的地址是通过公钥生成的,具体的:
```c++
String strAddress = PubKeyToAddress(GenerateNewKey());
```
GenerateNewKey函数返回一个公钥字符串,GenerateNewKey函数又依赖于AddKey函数,具体源码如下:
```c++

bool AddKey(const CKey& key)
{
    CRITICAL_BLOCK(cs_mapKeys)
    {
        mapKeys[key.GetPubKey()] = key.GetPrivKey();
        mapPubKeys[Hash160(key.GetPubKey())] = key.GetPubKey();
    }
    return CWalletDB().WriteKey(key.GetPubKey(), key.GetPrivKey());
}

vector<unsigned char> GenerateNewKey()
{
    CKey key;
    key.MakeNewKey();
    if (!AddKey(key))
        throw runtime_error("GenerateNewKey() : AddKey failed\n");
    return key.GetPubKey();
}
```
global类型map数组mapKeys存储私钥,key为公钥;global类型map数组mapPubKeys存储公钥,key为hash160(公钥).产生的公私钥对紧接着会持久化到DB,key为key.GetPubKey(), key.GetPrivKey()组成的字符串.上面代码中的CRITICAL_BLOCK宏是为了获取锁,理论上来说,为了保证线程安全,操作global变量时都应该事先获取锁.


PubKeyToAddress函数的源码如下:
```c++
static const unsigned char ADDRESSVERSION = 0;

inline string Hash160ToAddress(uint160 hash160)
{
    // add 1-byte version number to the front
    vector<unsigned char> vch(1, ADDRESSVERSION);
    vch.insert(vch.end(), UBEGIN(hash160), UEND(hash160));
    return EncodeBase58Check(vch);
}

inline string PubKeyToAddress(const vector<unsigned char>& vchPubKey)
{
    return Hash160ToAddress(Hash160(vchPubKey));
}
```
总之生成地址的步骤可以概括如下:

 1. 生成公私钥对
 2. 对公钥进行hash160(pubKey)计算hash值
 3. 将hash值编码成一个字符串,得到的就是一个地址
 
 
 比特币交易相关的类对象主要是在main.h中的COutPoint类,源码如下:
 ```c++
 class COutPoint
{
public:
    uint256 hash;
    unsigned int n;

    COutPoint() { SetNull(); }
    COutPoint(uint256 hashIn, unsigned int nIn) { hash = hashIn; n = nIn; }
    IMPLEMENT_SERIALIZE( READWRITE(FLATDATA(*this)); )
    void SetNull() { hash = 0; n = -1; }
    bool IsNull() const { return (hash == 0 && n == -1); }

    friend bool operator<(const COutPoint& a, const COutPoint& b)
    {
        return (a.hash < b.hash || (a.hash == b.hash && a.n < b.n));
    }

    friend bool operator==(const COutPoint& a, const COutPoint& b)
    {
        return (a.hash == b.hash && a.n == b.n);
    }

    friend bool operator!=(const COutPoint& a, const COutPoint& b)
    {
        return !(a == b);
    }

    string ToString() const
    {
        return strprintf("COutPoint(%s, %d)", hash.ToString().substr(0,6).c_str(), n);
    }

    void print() const
    {
        printf("%s\n", ToString().c_str());
    }
};


//
// An input of a transaction.  It contains the location of the previous
// transaction's output that it claims and a signature that matches the
// output's public key.
//
class CTxIn
{
public:
    COutPoint prevout;
    CScript scriptSig;
    unsigned int nSequence;
    ...
    }
    
    //
// An output of a transaction.  It contains the public key that the next input
// must be able to sign with to claim it.
//
class CTxOut
{
public:
    int64 nValue;
    CScript scriptPubKey;
...
};


//
// The basic transaction that is broadcasted on the network and contained in
// blocks.  A transaction can contain multiple inputs and outputs.
//
class CTransaction
{
public:
    int nVersion;
    vector<CTxIn> vin;
    vector<CTxOut> vout;
    int nLockTime;
    ...
    }
 ```
 一个CTransaction一般包含一组vin和vout,需要注意的是在vin中,包含了COutPoint prevout;它指明了当前的vin是哪一个交易的输出.
 
 任何一个**单笔**交易,要想唯一确定,那么就需要交易CTransaction的hash,以及这**单笔**交易在交易CTransaction的索引index.
 
 早期版本的比特币代码是支持以IP为地址发送比特币的,但是因为安全性等问题,后续版本的代码都把这个特性移除了.
 
 SendMoney函数的源代码如下:
 ```c++
 bool SendMoney(CScript scriptPubKey, int64 nValue, CWalletTx& wtxNew)
{
    CRITICAL_BLOCK(cs_main)
    {
        int64 nFeeRequired;
        if (!CreateTransaction(scriptPubKey, nValue, wtxNew, nFeeRequired))
        {
            string strError;
            if (nValue + nFeeRequired > GetBalance())
                strError = strprintf("Error: This is an oversized transaction that requires a transaction fee of %s  ", FormatMoney(nFeeRequired).c_str());
            else
                strError = "Error: Transaction creation failed  ";
            wxMessageBox(strError, "Sending...");
            return error("SendMoney() : %s\n", strError.c_str());
        }
        if (!CommitTransactionSpent(wtxNew))
        {
            wxMessageBox("Error finalizing transaction  ", "Sending...");
            return error("SendMoney() : Error finalizing transaction");
        }

        printf("SendMoney: %s\n", wtxNew.GetHash().ToString().substr(0,6).c_str());

        // Broadcast
        if (!wtxNew.AcceptTransaction())
        {
            // This must not fail. The transaction has already been signed and recorded.
            throw runtime_error("SendMoney() : wtxNew.AcceptTransaction() failed\n");
            wxMessageBox("Error: Transaction not valid  ", "Sending...");
            return error("SendMoney() : Error: Transaction not valid");
        }
        wtxNew.RelayWalletTransaction();
    }
    MainFrameRepaint();
    return true;
}
 ```
 其中scriptPubKey是公钥地址脚本,nValue是发送的金额,wtxNew是一个CTransaction类型的交易.
 该函数完成的功能如下:
 
 1. 创建交易,CreateTransaction(scriptPubKey, nValue, wtxNew, nFeeRequired)
 
 2. 持久化创建的交易数据到database,CommitTransactionSpent(wtxNew)
 
 3. 如果交易被认可,wtxNew.AcceptTransaction(),那么就将交易发送给其他节点进行wtxNew.RelayWalletTransaction()进行确认.
 
 创建交易CreateTransaction方法的源码如下:
 ```c++
 bool CreateTransaction(CScript scriptPubKey, int64 nValue, CWalletTx& wtxNew, int64& nFeeRequiredRet)
{
    nFeeRequiredRet = 0;
    CRITICAL_BLOCK(cs_main)
    {
        // txdb must be opened before the mapWallet lock
        CTxDB txdb("r");
        CRITICAL_BLOCK(cs_mapWallet)
        {
            int64 nFee = nTransactionFee;
            loop
            {
                wtxNew.vin.clear();
                wtxNew.vout.clear();
                if (nValue < 0)
                    return false;
                int64 nValueOut = nValue;
                nValue += nFee;

                // Choose coins to use
                set<CWalletTx*> setCoins;
                if (!SelectCoins(nValue, setCoins))
                    return false;
                int64 nValueIn = 0;
                foreach(CWalletTx* pcoin, setCoins)
                    nValueIn += pcoin->GetCredit();

                // Fill vout[0] to the payee
                wtxNew.vout.push_back(CTxOut(nValueOut, scriptPubKey));

                // Fill vout[1] back to self with any change
                if (nValueIn > nValue)
                {
                    /// todo: for privacy, should randomize the order of outputs,
                    //        would also have to use a new key for the change.
                    // Use the same key as one of the coins
                    vector<unsigned char> vchPubKey;
                    CTransaction& txFirst = *(*setCoins.begin());
                    foreach(const CTxOut& txout, txFirst.vout)
                        if (txout.IsMine())
                            if (ExtractPubKey(txout.scriptPubKey, true, vchPubKey))
                                break;
                    if (vchPubKey.empty())
                        return false;

                    // Fill vout[1] to ourself
                    CScript scriptPubKey;
                    scriptPubKey << vchPubKey << OP_CHECKSIG;
                    wtxNew.vout.push_back(CTxOut(nValueIn - nValue, scriptPubKey));
                }

                // Fill vin
                foreach(CWalletTx* pcoin, setCoins)
                    for (int nOut = 0; nOut < pcoin->vout.size(); nOut++)
                        if (pcoin->vout[nOut].IsMine())
                            wtxNew.vin.push_back(CTxIn(pcoin->GetHash(), nOut));

                // Sign
                int nIn = 0;
                foreach(CWalletTx* pcoin, setCoins)
                    for (int nOut = 0; nOut < pcoin->vout.size(); nOut++)
                        if (pcoin->vout[nOut].IsMine())
                            SignSignature(*pcoin, wtxNew, nIn++);

                // Check that enough fee is included
                if (nFee < wtxNew.GetMinFee(true))
                {
                    nFee = nFeeRequiredRet = wtxNew.GetMinFee(true);
                    continue;
                }

                // Fill vtxPrev by copying from previous transactions vtxPrev
                wtxNew.AddSupportingTransactions(txdb);
                wtxNew.fTimeReceivedIsTxTime = true;

                break;
            }
        }
    }
    return true;
}
 ```
该方法主要流程如下;
![此处输入图片的描述][1]
![此处输入图片的描述][2]
![此处输入图片的描述][3]
![此处输入图片的描述][4]
上面代码中的交易费用，需要注意的是比特币交易的佣金费用是由实际交易的字节大小决定的。上面代码中的GetMinFee，计算方法是1KB1cent，一个区块的前100个交易是免费的，且为了避免浪费最小交易费用是0.01cent，源代码如下：
```c++
int64 GetMinFee(bool fDiscount=false) const
    {
        // Base fee is 1 cent per kilobyte
        unsigned int nBytes = ::GetSerializeSize(*this, SER_NETWORK);
        int64 nMinFee = (1 + (int64)nBytes / 1000) * CENT;

        // First 100 transactions in a block are free
        if (fDiscount && nBytes < 10000)
            nMinFee = 0;

        // To limit dust spam, require a 0.01 fee if any output is less than 0.01
        if (nMinFee < CENT)
            foreach(const CTxOut& txout, vout)
                if (txout.nValue < CENT)
                    nMinFee = CENT;

        return nMinFee;
    }
```

CreateTransaction函数创建的交易CWalletTx& wtxNew需要进行签名，签名需要调用的函数就是SignSignature，这个函数有5个参数，其中的三个参数是CreateTransaction传递过来的，对应关系如下，txFrom是*pcoin，txTo是wtxNew，txTo是需要签名的对象，nIn是txTo的交易输入索引，源码如下：
```c++
bool SignSignature(const CTransaction& txFrom, CTransaction& txTo, unsigned int nIn, int nHashType, CScript scriptPrereq)
{
    assert(nIn < txTo.vin.size());
    CTxIn& txin = txTo.vin[nIn];
    assert(txin.prevout.n < txFrom.vout.size());
    const CTxOut& txout = txFrom.vout[txin.prevout.n];

    // Leave out the signature from the hash, since a signature can't sign itself.
    // The checksig op will also drop the signatures from its hash.
    uint256 hash = SignatureHash(scriptPrereq + txout.scriptPubKey, txTo, nIn, nHashType);

    if (!Solver(txout.scriptPubKey, hash, nHashType, txin.scriptSig))
        return false;

    txin.scriptSig = scriptPrereq + txin.scriptSig;

    // Test solution
    if (scriptPrereq.empty())
        if (!EvalScript(txin.scriptSig + CScript(OP_CODESEPARATOR) + txout.scriptPubKey, txTo, nIn))
            return false;

    return true;
}
```

SignSignature函数主要完成3个功能：

 1. 调用SignatureHash产生txTo的hash（对数据序列化，然后调用调用hash()函数计算hash）
 
 2. 调用Solver函数对产生的hash进行签名
 
 3. 调用EvalScript函数验证第二步签名
 
 SignatureHash函数源码如下：
 ```c++
 uint256 SignatureHash(CScript scriptCode, const CTransaction& txTo, unsigned int nIn, int nHashType)
{
    if (nIn >= txTo.vin.size())
    {
        printf("ERROR: SignatureHash() : nIn=%d out of range\n", nIn);
        return 1;
    }
    CTransaction txTmp(txTo);

    // In case concatenating two scripts ends up with two codeseparators,
    // or an extra one at the end, this prevents all those possible incompatibilities.
    scriptCode.FindAndDelete(CScript(OP_CODESEPARATOR));

    // Blank out other inputs' signatures
    for (int i = 0; i < txTmp.vin.size(); i++)
        txTmp.vin[i].scriptSig = CScript();
    txTmp.vin[nIn].scriptSig = scriptCode;

    // Blank out some of the outputs
    if ((nHashType & 0x1f) == SIGHASH_NONE)
    {
        // Wildcard payee
        txTmp.vout.clear();

        // Let the others update at will
        for (int i = 0; i < txTmp.vin.size(); i++)
            if (i != nIn)
                txTmp.vin[i].nSequence = 0;
    }
    else if ((nHashType & 0x1f) == SIGHASH_SINGLE)
    {
        // Only lockin the txout payee at same index as txin
        unsigned int nOut = nIn;
        if (nOut >= txTmp.vout.size())
        {
            printf("ERROR: SignatureHash() : nOut=%d out of range\n", nOut);
            return 1;
        }
        txTmp.vout.resize(nOut+1);
        for (int i = 0; i < nOut; i++)
            txTmp.vout[i].SetNull();

        // Let the others update at will
        for (int i = 0; i < txTmp.vin.size(); i++)
            if (i != nIn)
                txTmp.vin[i].nSequence = 0;
    }

    // Blank out other inputs completely, not recommended for open transactions
    if (nHashType & SIGHASH_ANYONECANPAY)
    {
        txTmp.vin[0] = txTmp.vin[nIn];
        txTmp.vin.resize(1);
    }

    // Serialize and hash
    CDataStream ss(SER_GETHASH);
    ss.reserve(10000);
    ss << txTmp << nHashType;
    return Hash(ss.begin(), ss.end());
}

 ```
 hash函数会进行**两次**sha256运算，源码如下所示：
 ```c++
 template<typename T1>
inline uint256 Hash(const T1 pbegin, const T1 pend)
{
    uint256 hash1;
    SHA256((unsigned char*)&pbegin[0], (pend - pbegin) * sizeof(pbegin[0]), (unsigned char*)&hash1);
    uint256 hash2;
    SHA256((unsigned char*)&hash1, sizeof(hash1), (unsigned char*)&hash2);
    return hash2;
}
 ```
 
 script.cpp文件中solver函数，它负责对SignatureHash函数返回的hash进行签名，源码如下：
 ```c++
 bool Solver(const CScript& scriptPubKey, uint256 hash, int nHashType, CScript& scriptSigRet)
{
    scriptSigRet.clear();

    vector<pair<opcodetype, valtype> > vSolution;
    if (!Solver(scriptPubKey, vSolution))
        return false;

    // Compile solution
    CRITICAL_BLOCK(cs_mapKeys)
    {
        foreach(PAIRTYPE(opcodetype, valtype)& item, vSolution)
        {
            if (item.first == OP_PUBKEY)
            {
                // Sign
                const valtype& vchPubKey = item.second;
                if (!mapKeys.count(vchPubKey))
                    return false;
                if (hash != 0)
                {
                    vector<unsigned char> vchSig;
                    if (!CKey::Sign(mapKeys[vchPubKey], hash, vchSig))
                        return false;
                    vchSig.push_back((unsigned char)nHashType);
                    scriptSigRet << vchSig;
                }
            }
            else if (item.first == OP_PUBKEYHASH)
            {
                // Sign and give pubkey
                map<uint160, valtype>::iterator mi = mapPubKeys.find(uint160(item.second));
                if (mi == mapPubKeys.end())
                    return false;
                const vector<unsigned char>& vchPubKey = (*mi).second;
                if (!mapKeys.count(vchPubKey))
                    return false;
                if (hash != 0)
                {
                    vector<unsigned char> vchSig;
                    if (!CKey::Sign(mapKeys[vchPubKey], hash, vchSig))
                        return false;
                    vchSig.push_back((unsigned char)nHashType);
                    scriptSigRet << vchSig << vchPubKey;
                }
            }
        }
    }

    return true;
}
 ```
 除了上面的4个参数的Solver函数，还有2个参数的Solver函数，源码如下：
 ```c++
 bool Solver(const CScript& scriptPubKey, vector<pair<opcodetype, valtype> >& vSolutionRet)
{
    // Templates
    static vector<CScript> vTemplates;
    if (vTemplates.empty())
    {
        // Standard tx, sender provides pubkey, receiver adds signature
        vTemplates.push_back(CScript() << OP_PUBKEY << OP_CHECKSIG);

        // Short account number tx, sender provides hash of pubkey, receiver provides signature and pubkey
        vTemplates.push_back(CScript() << OP_DUP << OP_HASH160 << OP_PUBKEYHASH << OP_EQUALVERIFY << OP_CHECKSIG);
    }

    // Scan templates
    const CScript& script1 = scriptPubKey;
    foreach(const CScript& script2, vTemplates)
    {
        vSolutionRet.clear();
        opcodetype opcode1, opcode2;
        vector<unsigned char> vch1, vch2;

        // Compare
        CScript::const_iterator pc1 = script1.begin();
        CScript::const_iterator pc2 = script2.begin();
        loop
        {
            bool f1 = script1.GetOp(pc1, opcode1, vch1);
            bool f2 = script2.GetOp(pc2, opcode2, vch2);
            if (!f1 && !f2)
            {
                // Success
                reverse(vSolutionRet.begin(), vSolutionRet.end());
                return true;
            }
            else if (f1 != f2)
            {
                break;
            }
            else if (opcode2 == OP_PUBKEY)
            {
                if (vch1.size() <= sizeof(uint256))
                    break;
                vSolutionRet.push_back(make_pair(opcode2, vch1));
            }
            else if (opcode2 == OP_PUBKEYHASH)
            {
                if (vch1.size() != sizeof(uint160))
                    break;
                vSolutionRet.push_back(make_pair(opcode2, vch1));
            }
            else if (opcode1 != opcode2)
            {
                break;
            }
        }
    }

    vSolutionRet.clear();
    return false;
}
 ```
 接下来是验证签名的函数，EvalScript函数负责对签名进行验证。
 
 总结：CreateTransaction函数完成新交易的创建，以及对交易进行签名。
 
**下面是比特币的序列化部分。**

比特币所有的序列化函数都在serialize.h文件中，该文件中的类CDataStream是该文件主要的数据结构类对象。
```c++
//
// Double ended buffer combining vector and stream-like interfaces.
// >> and << read and write unformatted data using the above serialization templates.
// Fills with data in linear time; some stringstream implementations take N^2 time.
//
class CDataStream
{
protected:
    typedef vector<char, secure_allocator<char> > vector_type;
    vector_type vch;
    unsigned int nReadPos;
    short state;
    short exceptmask;
public:
    int nType;
    int nVersion;

    ...
};
```

序列化以后的数据放在vch变量中，state表示序列化/反序列化过程中出现的错误码，exceptmask定义错误类型，nType表示序列化的类型，源码如下：

```c++

/////////////////////////////////////////////////////////////////
//
// Templates for serializing to anything that looks like a stream,
// i.e. anything that supports .read(char*, int) and .write(char*, int)
//

enum
{
    // primary actions
    SER_NETWORK         = (1 << 0),
    SER_DISK            = (1 << 1),
    SER_GETHASH         = (1 << 2),

    // modifiers
    SER_SKIPSIG         = (1 << 16),
    SER_BLOCKHEADERONLY = (1 << 17),
};
```

CDataStream::read方法拷贝nSize大小的数据到指针char* pch指向的内存空间中（反序列化过程），源码如下：
```c++
CDataStream& read(char* pch, int nSize)
    {
        // Read from the beginning of the buffer
        assert(nSize >= 0);
        unsigned int nReadPosNext = nReadPos + nSize;
        if (nReadPosNext >= vch.size())
        {
            if (nReadPosNext > vch.size())
            {
                setstate(ios::failbit, "CDataStream::read() : end of data");
                memset(pch, 0, nSize);
                nSize = vch.size() - nReadPos;
            }
            memcpy(pch, &vch[nReadPos], nSize);
            nReadPos = 0;
            vch.clear();
            return (*this);
        }
        memcpy(pch, &vch[nReadPos], nSize);
        nReadPos = nReadPosNext;
        return (*this);
    }
```

CDataStream::write方法，拷贝nSize大小的数据到vch（序列化过程），源码如下：
```c++
CDataStream& write(const char* pch, int nSize)
    {
        // Write to the end of the buffer
        assert(nSize >= 0);
        vch.insert(vch.end(), pch, pch + nSize);
        return (*this);
    }
```

上面两个函数一般用于序列化/反序列化简单类型（int、bool、unsigned long，etc），他们都会被序列化成字符类型char的形式（区别于字节类型）。

下面讲解一下如何具体序列化一个类。

一般而言，一个类需要实现如下三个方法才能实现序列化/反序列化。
![此处输入图片的描述][5]

**接下来讲解一下比特币的script。**

比特币使用了基于栈（stack）的脚本语言。脚本嵌入在输出的交易列表中。本节所有的代码都在script.h或者script.cpp中。

操作符作用于栈提供的数据，产生的数据重新入栈时就产生了输出数据。

脚本语言由操作符和操作数组成。操作符的枚举类型源码如下：
```c++
enum opcodetype
{
    // push value
    OP_0=0,
    OP_FALSE=OP_0,
    OP_PUSHDATA1=76,
    OP_PUSHDATA2,
    OP_PUSHDATA4,
    OP_1NEGATE,
    OP_RESERVED,
    OP_1,
    OP_TRUE=OP_1,
    OP_2,
    OP_3,
    OP_4,
    OP_5,
    OP_6,
    OP_7,
    OP_8,
    OP_9,
    OP_10,
    OP_11,
    OP_12,
    OP_13,
    OP_14,
    OP_15,
    OP_16,

    // control
    OP_NOP,
    OP_VER,
    OP_IF,
    OP_NOTIF,
    OP_VERIF,
    OP_VERNOTIF,
    OP_ELSE,
    OP_ENDIF,
    OP_VERIFY,
    OP_RETURN,

    // stack ops
    OP_TOALTSTACK,
    OP_FROMALTSTACK,
    OP_2DROP,
    OP_2DUP,
    OP_3DUP,
    OP_2OVER,
    OP_2ROT,
    OP_2SWAP,
    OP_IFDUP,
    OP_DEPTH,
    OP_DROP,
    OP_DUP,
    OP_NIP,
    OP_OVER,
    OP_PICK,
    OP_ROLL,
    OP_ROT,
    OP_SWAP,
    OP_TUCK,

    // splice ops
    OP_CAT,
    OP_SUBSTR,
    OP_LEFT,
    OP_RIGHT,
    OP_SIZE,

    // bit logic
    OP_INVERT,
    OP_AND,
    OP_OR,
    OP_XOR,
    OP_EQUAL,
    OP_EQUALVERIFY,
    OP_RESERVED1,
    OP_RESERVED2,

    // numeric
    OP_1ADD,
    OP_1SUB,
    OP_2MUL,
    OP_2DIV,
    OP_NEGATE,
    OP_ABS,
    OP_NOT,
    OP_0NOTEQUAL,

    OP_ADD,
    OP_SUB,
    OP_MUL,
    OP_DIV,
    OP_MOD,
    OP_LSHIFT,
    OP_RSHIFT,

    OP_BOOLAND,
    OP_BOOLOR,
    OP_NUMEQUAL,
    OP_NUMEQUALVERIFY,
    OP_NUMNOTEQUAL,
    OP_LESSTHAN,
    OP_GREATERTHAN,
    OP_LESSTHANOREQUAL,
    OP_GREATERTHANOREQUAL,
    OP_MIN,
    OP_MAX,

    OP_WITHIN,

    // crypto
    OP_RIPEMD160,
    OP_SHA1,
    OP_SHA256,
    OP_HASH160,
    OP_HASH256,
    OP_CODESEPARATOR,
    OP_CHECKSIG,
    OP_CHECKSIGVERIFY,
    OP_CHECKMULTISIG,
    OP_CHECKMULTISIGVERIFY,


    // multi-byte opcodes
    OP_SINGLEBYTE_END = 0xF0,
    OP_DOUBLEBYTE_BEGIN = 0xF000,

    // template matching params
    OP_PUBKEY,
    OP_PUBKEYHASH,



    OP_INVALIDOPCODE = 0xFFFF,
};
```

类CScript表示了一个可解析、可执行的脚本。类CScript重写了<<操作符，实现了将脚本指令写进CScript对象中。读取的话，可以使用CScript::GetOp()方法将脚本指令内容提取出来，源代码如下：
```c++
bool GetOp(const_iterator& pc, opcodetype& opcodeRet, vector<unsigned char>& vchRet) const
    {
        opcodeRet = OP_INVALIDOPCODE;
        vchRet.clear();
        if (pc >= end())
            return false;

        // Read instruction
        unsigned int opcode = *pc++;
        if (opcode >= OP_SINGLEBYTE_END)
        {
            if (pc + 1 > end())
                return false;
            opcode <<= 8;
            opcode |= *pc++;
        }

        // Immediate operand
        if (opcode <= OP_PUSHDATA4)
        {
            unsigned int nSize = opcode;
            if (opcode == OP_PUSHDATA1)
            {
                if (pc + 1 > end())
                    return false;
                nSize = *pc++;
            }
            else if (opcode == OP_PUSHDATA2)
            {
                if (pc + 2 > end())
                    return false;
                nSize = 0;
                memcpy(&nSize, &pc[0], 2);
                pc += 2;
            }
            else if (opcode == OP_PUSHDATA4)
            {
                if (pc + 4 > end())
                    return false;
                memcpy(&nSize, &pc[0], 4);
                pc += 4;
            }
            if (pc + nSize > end())
                return false;
            vchRet.assign(pc, pc + nSize);
            pc += nSize;
        }

        opcodeRet = (opcodetype)opcode;
        return true;
    }
```

pc参数指向SCript内部指令存储的位置，读取出的指令会依次放到opcodeRet和vchRet。具体的：

![此处输入图片的描述][6]


    




 

 
 
 
 
 

以太坊
===

hyperledger
===========

corda
=====


  [1]: https://github.com/WQZ321123/learn/blob/master/image/bitcoin/create_transaction%281%29.png?raw=true
  [2]: https://github.com/WQZ321123/learn/blob/master/image/bitcoin/create_transaction%282%29.png?raw=true
  [3]: https://github.com/WQZ321123/learn/blob/master/image/bitcoin/create_transaction%283%29.png?raw=true
  [4]: https://github.com/WQZ321123/learn/blob/master/image/bitcoin/create_transaction%284%29.png?raw=true
  [5]: https://github.com/WQZ321123/learn/blob/master/image/bitcoin/serialization.png?raw=true
  [6]: https://github.com/WQZ321123/learn/blob/master/image/bitcoin/readInstruction.png?raw=true