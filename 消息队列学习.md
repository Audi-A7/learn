# 消息队列学习

标签（空格分隔）： rabbitmq

---
os:macOs 10.14.5

docker:18.09.2

安装rabbitmq
----------
个人认为，使用docker安装是一种比较简单优雅的方式，下面介绍一下docker安装rabbitmq。

 - 拉取镜像并启动

 ```linux
 docker run rabbitmq:3.7.17-management
 
 docker run -d --hostname my-rabbit -p 5671:5671 -p 5672:5672 -p 4369:4369 -p 25672:25672 -p 15671:15671 -p 15672:15672  --name test-rabbit rabbitmq:3.7.17-management
 
 # 查看一下rabbitmq是否启动成功
 {19-08-14 16:08}[ruby-2.3.7]t4f-mbp-17055:~/elk wangquanzhou% docker ps
CONTAINER ID        IMAGE                        COMMAND                  CREATED              STATUS                          PORTS                                                                                                                      NAMES
80f14b204f14        rabbitmq:3.7.17-management   "docker-entrypoint.s…"   About a minute ago   Up About a minute               0.0.0.0:4369->4369/tcp, 0.0.0.0:5671-5672->5671-5672/tcp, 0.0.0.0:15671-15672->15671-15672/tcp, 0.0.0.0:25672->25672/tcp   test-rabbit
 ```

 - web页面
浏览器输入http://localip:15672/进行登录，用户名、密码guest/guest
 
hello world
-----------
做一个简单的demo，连接rabbitmq，并发送测试消息，首先是生产者：
```java
package com.bfxy.rabbitmq.quickstart;

import com.rabbitmq.client.Channel;
import com.rabbitmq.client.Connection;
import com.rabbitmq.client.ConnectionFactory;

public class Procuder {


    public static void main(String[] args) throws Exception {
        //1 创建一个ConnectionFactory, 并进行配置
        ConnectionFactory connectionFactory = new ConnectionFactory();
        connectionFactory.setHost("172.20.150.108");
        connectionFactory.setPort(5672);
        connectionFactory.setVirtualHost("/");

        //2 通过连接工厂创建连接
        Connection connection = connectionFactory.newConnection();

        //3 通过connection创建一个Channel
        Channel channel = connection.createChannel();

        //4 通过Channel发送数据
        for (int i = 0; i < 5; i++) {
            String msg = "Hello RabbitMQ!";
            //1 exchange   2 routingKey
            channel.basicPublish("", "test001", null, msg.getBytes());
        }

        //5 记得要关闭相关的连接
        channel.close();
        connection.close();
    }
}
```

然后是消费者：
```java
package com.bfxy.rabbitmq.quickstart;

import com.rabbitmq.client.Channel;
import com.rabbitmq.client.Connection;
import com.rabbitmq.client.ConnectionFactory;
import com.rabbitmq.client.QueueingConsumer;
import com.rabbitmq.client.QueueingConsumer.Delivery;

public class Consumer {

    public static void main(String[] args) throws Exception {

        //1 创建一个ConnectionFactory, 并进行配置
        ConnectionFactory connectionFactory = new ConnectionFactory();
        connectionFactory.setHost("172.20.150.108");
        connectionFactory.setPort(5672);
        connectionFactory.setVirtualHost("/");

        //2 通过连接工厂创建连接
        Connection connection = connectionFactory.newConnection();

        //3 通过connection创建一个Channel
        Channel channel = connection.createChannel();

        //4 声明（创建）一个队列
        String queueName = "test001";
        channel.queueDeclare(queueName, true, false, false, null);

        //5 创建消费者
        QueueingConsumer queueingConsumer = new QueueingConsumer(channel);

        //6 设置Channel
        channel.basicConsume(queueName, true, queueingConsumer);

        while (true) {
            //7 获取消息
            Delivery delivery = queueingConsumer.nextDelivery();
            String msg = new String(delivery.getBody());
            System.err.println("消费端: " + msg);
            //Envelope envelope = delivery.getEnvelope();
        }

    }
}
```
先启动消费端，创建队列，然后启动生产端，发送消息：

消费端控制台输出如下：
```java
消费端: Hello RabbitMQ!
消费端: Hello RabbitMQ!
消费端: Hello RabbitMQ!
消费端: Hello RabbitMQ!
消费端: Hello RabbitMQ!
```

消息手动ack
-------
为了保证消息的投递成功，即100%消费，一般可以使用ack机制进行确认。rabbitmq默认自动ack，当然也可以设置抖动ack。

下面，我们先看一下业界一般的保证消息确认性投递的架构设计，如下图所示：

 1. 方案一

核心思想就是，消息发送之前先对消息进行入库，然后等消息ack回来以后，再修改消息的状态。但是这样对于并发要求较高的系统一般不容易满足要求。

 ![此处输入图片的描述][1]
 
  2. 方案二

这种方式，对于同一通知产生两条消息，如下图所示。两条消息一前一后相继发送，前一条消息主要传递通知所承载的业务信息，后一条消息主要负责检测前一条业务消息是否投递成功。
   ![此处输入图片的描述][2]
   
   基于上面的图，自己整理除了下面的图。第1-6步是第一条消息的投递过程。7-9步是第二条消息的投递过程（第9步发生的前提的，第一条消息消费失败了）。下面分别就合格步骤讲解一下。
   
   

 1. upstream service产生的消息存入数据库
 2. 发生该条业务消息给biz queue这个队列
 3. downStream service监听biz queue队列，获得业务消息，并进行处理
 4. downStream service反馈处理结果给ack queue
 5. callback service监听ack queue，获得业务消息处理结果
 6. 处理结果存储在msg db
 7. upstream service发生second确认消息，消息路由到second check queue队列
 8. callback service监听second check queue，获得second确认消息，从msg db查询确认消息对应的业务消息的ack情况
 9. 如果业务消息消费失败了，那么callback service通知upstream service进行消息重发
 

![此处输入图片的描述][3]   

 - 手动ack

 


  [1]: https://github.com/Audi-A7/learn/blob/master/image/rabbitmq/11.png?raw=true
  [2]: https://github.com/Audi-A7/learn/blob/master/image/rabbitmq/12.png?raw=true
  [3]: https://github.com/Audi-A7/learn/blob/master/image/rabbitmq/%E6%B6%88%E6%81%AF%E5%8F%AF%E9%9D%A0%E6%80%A7%E6%8A%95%E9%80%92.png?raw=true